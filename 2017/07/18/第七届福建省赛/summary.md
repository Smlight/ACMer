### C. Card Game (First Edition)
直接当成同一个人抽的，那么由抽签问题，这次抽到某张牌和这张牌在某次抽到的概率全都是相等的。

对于一张牌，满足下面两个条件可以得分：

 1. 出现在奇数位置；
 2. 右边位置的牌比它小

对牌排序，那么对于第i张牌(0~2n-1)，它能得到的分为 $\sum_j^n p_j*q_i$，
其中j为奇数；$p_j$为第i张牌出现在j位置的概率，总等于1/2n；$q_i$为比i小的牌出现在i的右边的概率。
因为牌各不相等，所以一定有i个比第i张牌小的，又因为j位置已经确定，所以$q_i=i/(2n-1)$。

很显然，排序没用了，而且再化简就会发现答案等于n/2。

实际上如果我们一开始就考虑总的分数一定是n，又由于两人期望相等(轮换对称性)，那么一下子就能知道答案等于n/2 ←_← 

### D. Card Game (Second Edition)
每次得分期望为，对方出的牌小于这张牌，相加即可。

### F. The Bigger the Better
用两个指针指向两个数组：

 - 如果两个数不相等，那么显然是放大的数；
 - 如果两个数相等，那么要一直往后找到第一个不相等的位置判断大小。

如果按照这个想法朴素的实现，那么复杂度就是O(n^2)。

从第二种情况联想到后缀，发现后缀数组就是为了解决后缀排序这个问题，进一步地，第一种情况可以算一种特例。
这样实现起来就很容易了，复杂度O(nlogn)。

### I. Two Triangles
先取三个点，用两边之和大于第三边判断构成三角形，再取三个点，用SSS判断全等，再用对应向量边叉积判断没有翻转。

实现起来比较恶心。。。思路一定要够清晰。

### J. X
Floyd。i，j之间的路径能被k更新就表示(i,j)能被删除，注意一下不能删不存在的边也不能删多次就可以了。
