A.
用优先队列维护当前的怪物，每干掉一只怪物就把 当前能到达的但是之前未到达过的点 的怪物加进优先队列里

B.
枚举a，枚举b，枚举a*b，算出一个mx1数组表示用i元可以得到头盔首饰的最大的攻击
枚举c，枚举d，枚举c * (c - 1) /2，算出一个mx2数组表示用i元得到的武器的最大攻击
然后再枚举一次mx1[i] + mx2[m-i+1]即可

C.
d[i][j]表示从左上走到(i, j) 右下走到(n - j + 1, n - i + 1)的距离和方案
然后跑最短路的时候更新距离和方案即可

D.
判断叶子数<=非叶子数+1且不存在相邻的#

E.
水满的情况时，水面满足先非递减后非递增
找到最长的那个柱子，然后左右分别扫一次即可

F.
dfs+容斥
枚举每个子集的lcm
然后res = res + 1e9 / lcm * (子集元素个数为偶数?1:-1)
优化1去重，优化2如果ai%aj==0那么去掉ai，优化3 lcm大于1e9时退出
虽然优化1好像并没有什么用

G.
不会做了..